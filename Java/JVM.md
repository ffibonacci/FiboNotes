## Java Virtual Machine

__JVM__ - виртуальная машина, которая исполняет Java байт-код. JVM не понимает исходный код Java, поэтому необходимо скомпилировать *.java для получения *.class файла, который содержит байт-код.

*JVM реализует основную идею Java: "Write Once - Run Anywhere" (WORA).*

</br>

#### Java Class file

1 класс - 1 класс-файл

__Constant Pool__

- числа, строки
- указатели на классы, методы, поля

__Описание класса__

- имя
- поля
- модификаторы
- методы
- супер класс
- атрибуты
- супер интерфейсы

Поля, методы тоже имеют атрибуты (например, значения константных полей).

Главный атрибут метода - это его код: Java байт-код.

#### Java byte code

* массив инструкций
* стэк операндов инструкций метода
* массив локальных переменных (аргументы метода, локальные переменные)

__Программа для JVM__

любая программа исполняемая на JVM имеет:

* main class </br>

  ```public static void main(String[] args)```

* classpath - список директорий и архивов (jar файлов)

* В веб-приложениях программа для JVM - это веб-сервер: Tomcat, GlassFish, etc.

#### Java Runtime

Для исполнения программы на JVM необходим JRE (Java Runtime Environment):

* JVM
* платформенные классы 
  - core классы (java.lang.Object, java.lang.String, etc.)
  - Java Standard APIs (IO, NET, NIO, AWT/Swing, etc.)
* реализация native-методов платформенных классов (OS specific)
* вспомогательные файлы (описатели временных зон, медиа ресурсы, etc.)

![](https://devngrow.com/images/jvm.png)

#### Classloading engine (загрузка классов)

__Где JVM берет классы для исполнения ?__

- из Java Runtime (платформенные классы)
- из classpath приложения
- автоматически сгенерированные налету (Proxy, Reflection accessors, реализация invoke dynamic)
- предоставленные самим приложением

__Каждый класс грузится загрузчиком классов__

- для платформенных классов это __bootstrap загрузчик__;
- для классов из classpath приложения это __системный загрузчик__ (AppClassLoader);
- классы приложения могут создавать свои загрузчики, которые будут грузить классы

*Загрузчик классов образует уникальное пространство имен классов.*

#### Старт JVM

1. Грузится main класс системным загрузчиком (из classpath приложения)

   1.1 провоцирует загрузку части платформенных классов (core)

2. Исполняется метод main(String[] args)

#### Процесс загрузки класса (создание класса)

* Читается class file: проверяется корректность формата (может выбросить ClassFormatError)
* Создается рантайм представление класса в выделенной области памяти: runtime constant pool in Method Area aka Meta Space aka Permanent Generation
* Грузятся суперкласс, суперинтерфейсы

#### Линковка

* верификация байт-кода:
  * происходит с классом один раз;
  * проверка корректности инструкций (корректности переходов);
  * проверка выхода за пределы стэка операндов и локальных переменных;
  * проверка совместимости типов.
* подготовка;
* размещение символьных ссылок.

__Инициализация класса__

* вызов статического инициализатора класса;
* случается при первом использовании:
  * new
  * доступ до статического поля
  * вызов статического метода
* провоцирует инициализацию статического супер-класса и супер-интерфейсов с default методами.

#### Исполнение Java байт-кода

JVM может исполнять байт-код двумя способами:

* интерпретировать;
* транслировать в машинный код, который будет исполняться непосредственно на CPU.

##### Компиляторы

* неоптимизирующие;
* простые оптимизирующие (пример: HotSpot Client);
* сложные оптимизирующие (пример: HotSpot Server).

- **Динамические (Just-In-Time/JIT)** *(трансляция в машинный код происходит во время исполнения программы)*:

  + работают одновременно с исполняемой программой;
  + компилируют __горячий__ код(код, который чаще исполняется);
  + горячий код вычисляется с помощью динамического профилировщика;
  + используют информацию времени исполнения для оптимизаций.
  
- **Статические (Ahead-Of-Time/AOT)** (*трансляция происходит до исполнения программы*):

  + не ограничены в ресурсах для оптимизации программ;
  + компилирует каждый метод программы используя самые агрессивные оптимизации;
  + на оптимизацию не тратятся ресурсы во время исполнения программы (быстрее старт).
  
  

  #### Reflection

  * позволяет достучаться до классов, полей, методов по имени из Java программы;
  * реализуется в JVM через доступ в Meta Space;
  * ключевая возможность Java для многих популярных фреймворков и реализаций языков на JVM.
  
  

  #### Java Native Interface (JNI)

  + связывает JVM с внешним миром (OS);
  + Си интерфейс к JVM:
    + не зависит от реализации JVM;
    + используется для релизации native методов на языке Си (или другом систеном языке);
    + с помощью JNI написаны платформенно-зависимые реализации Java SE API: IO, NET, AWT.
  + релизуется в JVM как доступ к Meta Space.



#### java.lang.Thread

* Java поток мапируется на нативный поток в соотношение 1-1;

* с потоком связана память используемая для локальных переменных и стэка операндов методов (фреймов методов): стэк; </br>

  размер стэка - параметр JVM: -Xss

* имеет информацию о стэке вызовов методов потока (stack trace)</br>

  *в любой момент может о нем рассказать, помогает в обработке исключений*

__Синхронизация__

+ для безопасного доступа к разделяемой памяти между потоками;
+ в нативной реализации используются средства ОС: ОС монитор есть в каждом Java объекте как скрытое поле;
+ оптимизирована когда конкуренция за ресурс происходит много реже, чем вход в synchronized.

### Memory Management. Garbage Collection

#### Выделение памяти

+ релизация оператора __new__;
+ объекты, выделенные с помощью оператора __new__ распологаются в т.н. куче (__Java Heap__);
+ организация __Java Heap__ JVM-специфична;
+ размтека (layout) Java объекта тоже JVM-специфична.

#### Аллокация объектов

+ должна быть быстрой
  + JVM запрашивает у ОС память не под один объект, а сразу на много;
  + аллокация методом продвижения границы;
+ потоко-безопасной (thread-safe), но при этом параллельной (не блокирующей);
  + Thread local heaps: каждый поток "грызет" свой кусок памяти.

#### Layout Java объекта

Не специфицируется JVM, но по факту требует:

+ Java Object header:

  + указатель на класс;
  + монитор (lock);
  + identity hashcode;
  + флаги для GC.

+ Поля

  могут быть предупорядочены из соображений экономии размера, выравнивания, особенностей целевой архитектуры



#### Сборка мусора

![](https://devngrow.com/images/gc.png)

__Пространство Эдема__ - все новые объекты появляются здесь и им выделяется начальная память.

__Пространство выживщих__ - объекты перемещаются сюда из Эдема после того как пережили один цикл сборки мусора.

Процесс, когда объекты собираются в мусор из молодого поколения, называется *малым событием сборки мусора*.

Процесс, когда объекты отправляются в мусор из старшего поколения, называется *основным событием сборки мусора*.

__Не мусор(живые объекты):__

+ объекты из корневого множества
+ объекты, на которые ссылаются живые объекты

__Корневое множество объектов (GC roots)__

1. объекты в статических полях классов
2. объекты доступные со стэка Java потоков
3. объекты из JNI ссылок в native методах

*Все остальное - **мусор**.*

#### Трассирующие сборщики

+ mark-and-sweep 
  - помечает живые объекты (mark), "выметает" (удаляет) мусор (sweep).
+ stop-and-copy
  + копирует живые объекты в специальное место (copy)
  + освободившиеся место (мусор и места где были живые объекты) может использовать для новой аллокации.

__Stop the World__

+ живые объекты определены для определенного момента исполнения программы (при исполнении множество меняется)
+ чтобы собрать мусор в общем случае нужно остановить потоки, чтобы определить где мусор (STW пауза)

__Методы уменьшения STW паузы:__

+ Инкрементальный (собирать не весь мусор в паузе)
+ Параллельный (собирать мусор во многих потоках в паузе)
+ Одновременный (concurrent) (собирать мусор одновременно с работой программы, не останавливая потоки)

#### Поколенная сборка мусора

__Слабая гипотеза о поколениях:__

+ большинство объектов умирает молодыми;
+ старые объекты редко ссылаются на молодые.

__Поколенный (generational) GC:__

+ частный вид инкрементального
+ во время т.н. малых сборок удаляем мусор среди молодых объектов
+ объекты, переживающие одну или несколько сборок, перемещаем в область старого поколения

Поскольку Java задействует сборку мусора по поколениям, то чем больше  событий сборки мусора переживает объект, тем дальше он продвигается в  куче. Он начинает в молодом поколении и в конечном итоге заканчивает в  штатном поколении, если проживет достаточно долго.

*Чтобы узнать какой GarbageCollector используется необходимо выполнить команду:*

```java -XX:+PrintCommandLineFlags -version```

Начиная с версии 9 используется сборщик мусора G1 по умолчанию (java 17 lts также использует G1).

Начиная с Java 8, на смену пространству постоянного поколения  (PermGen) приходит пространство памяти __MetaSpace__. Реализация отличается  от PermGen  —  это пространство кучи теперь изменяется автоматически.

Это позволяет избежать проблемы нехватки памяти у приложений, которая возникает из-за ограниченного размера пространства PermGen в куче.  Память мета-пространства может быть собрана как мусор, и классы, которые больше не используются, будут автоматически очищены, когда  мета-пространство достигнет максимального размера.

__G1__ также действует по принципу поколений, но в нем нет отдельных  пространств для молодого и старшего поколений. Вместо этого каждое  поколение представляет собой набор областей, что позволяет гибко  изменять размер молодого поколения.

G1 разбивает кучу на набор областей одинакового размера (от 1 МБ до  32 МБ  —  в зависимости от размера кучи) и сканирует их в несколько  потоков. Область во время выполнения программы может неоднократно  становиться как старой, так и молодой.

После завершения этапа разметки G1 знает, в каких областях содержится больше всего мусора. Если пользователь заинтересован в минимизации  пауз, G1 может выбрать только несколько областей. Если время паузы  неважно для пользователя или предел этого времени установлен высокий, G1 пройдет по большему числу областей.

Поскольку G1 GC идентифицирует регионы с наибольшим количеством мусора и сначала выполняет сбор мусора в них, он и называется: “Мусор  —   первым”.

Помимо областей *Эдема*, *Выживших* и *Старой памяти*, в G1GC присутствуют еще два типа.

- *Humongous (Огромная)*  —  для объектов большого размера (более 50% размера кучи).
- *Available (Доступная*)  —  неиспользуемое или не выделенное пространство.

### Manageability & Monitoring

##### JVM Tool Interface (JVM TI):

+ отладчики
+ профилировщики

##### Java Management Beans

+ инструменты мониторинга запущенных приложений
  + JConsole, JMX Console, AMC
  + Visual VM
  + Java Mission Control

*JVM TI используется при дебагинге.*

#### Реализации JVM

Совместимые с JAVA SE спецификацией:

+ Oracle HotSpot
+ IBM J9
+ Excelsior JET
+ Azul (HotSpot based, со своим GC)
+ SAP, RedHat (порты HotSpot на разные платформы)



___


Источники:

[JPoint: Никита Липский, Владимир Иванов — JVM: краткий курс общей анатомии](https://www.youtube.com/watch?v=-fcj6EL9rc4&list=WL&index=1)

[Сборка мусора в Java: что это такое и как работает в JVM](https://nuancesprog.ru/p/12392/)
