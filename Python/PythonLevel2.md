# Python Level 2.

### [Шебанг](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D0%B1%D0%B0%D0%BD%D0%B3_(Unix)) - последовательность символов #! <br/>
```
#!/usr/bin/env python
```

### **```*args & **kwargs```**

*args и **kwargs в основном используются в определениях функций. *args и **kwargs позволяют передавать им произвольное число аргументов. 
Под произвольным числом здесь понимается ситуация, когда вы не знаете заранее сколько аргументов может быть передано функции пользователем, 
поэтому в данном случае вам необходимо использовать эти ключевые слова. 
*args используется для передачи произвольного числа неименованных аргументов функции. </br>
Вот пример, чтобы помочь вам понять идею:</br>
 
```
def test_var_args(f_arg, *argv):
    print("Первый позиционный аргумент:", f_arg) 
    for arg in argv:
        print("Другой аргумент из *argv:", arg) 
test_var_args('yasoob', 'python', 'eggs', 'test')
```

Результат будет таким:
```
Первый позиционный аргумент: yasoob
Другой аргумент из *argv: python
Другой аргумент из *argv: eggs
Другой аргумент из *argv: test
```

### Использование **kwargs


**kwargs позволяет вам передавать произвольное число именованных аргументов в функцию. 
Таким образом, вам необходимо использовать **kwargs там, где вы хотите работать с именованными аргументами.</br>
Очередной пример:</br>
```
def greet_me(**kwargs):
    for key, value in kwargs.items():
        print("{0} = {1}".format(key, value))
greet_me(name="yasoob")
```
`> name = 'yasoob' `

В результате, мы оперируем произвольным числом именованных аргументов в нашей функции. 
Это были основы использования **kwargs и можете сами отметить насколько это может быть удобно в определенных ситуациях. 
Теперь давайте рассмотрим использование *args и **kwargs для передачи в функцию списка или словаря аргументов.


### Использование *args и **kwargs при вызове функции

Рассмотрим вызов функции, используя ***args** и ****kwargs**. Пусть у нас есть вот такая небольшая функция:
```
def test_args_kwargs(arg1, arg2, arg3): 
    print("arg1:", arg1)
    print("arg2:", arg2)
    print("arg3:", arg3)
```
Мы можем использовать *args или **kwargs чтобы передать в неё аргументы. Вот как мы это сделаем:


#### Сначала с *args
```
args = ("two", 3, 5)
test_args_kwargs(*args)
```
`> arg1: two` <br/>
`> arg2: 3` <br/>
`> arg3: 5` <br/>

#### Теперь с **kwargs:
```
kwargs = {"arg3": 3, "arg2": "two", "arg1": 5}
test_args_kwargs(**kwargs)
```
`> arg1: 5` <br/>
`> arg2: two` <br/>
`> arg3: 3` <br/>


## Отладка:

`$ python -m pdb my_script.py`

```
import pdb
def make_bread(): 
    pdb.set_trace() # установка контрольной точки для дебаггера
    return "У меня нет времени" 
print(make_bread())
```
**Команды:** <br/>
> c : продолжить выполнения программы <br/>
> w : отобразить окружение текущей исполняемой инструкции <br/>
> a : отобразить список аргументов текущей функции <br/>
> s : исполнить текущую строчку кода и остановиться по возможности <br/>
> n : продолжить исполнение программы пока не будет достигнута следующая 
строка текущей функции или пока функция не завершит свою работу <br/>

***Разница между n и s в том, что вторая команда приостановит исполнение после вызова функции, а первая только после достижения следующей строки текущей функции.*** 
</br></br>

### **Итерируемый объект**
Итерируемым объектом в Python называется любой объект, имеющий методы **```__iter__```** или **```__getitem__```** , которые возвращают итераторы или могут принимать
индексы. В итоге итерируемый объект это объект, который может предоставить нам итератор.

> **Итератор**<br/>
Итератором в Python называется объект, который имеет метод next (Python 2) или **```__next__```** . Вот и все. Это итератор.

> **Итерация**<br/>
Если коротко - это процесс получения элементов из какого-нибудь источника, например списка. Итерация - это процесс перебора элементов объекта в цикле. 


### **Генераторы**
Генераторы это итераторы, по которым можно итерировать только один раз. Так происходит поскольку они не хранят все свои значения в памяти, а генерируют элементы "на лету". Генераторы можно использовать с циклом for или любой другой функцией или конструкцией, которые позволяют итерировать по объекту. В большинстве случаев генераторы создаются как функции. Тем не менее, они не возвращают значение также как функции (т.е. через return), в генераторах для этого используется ключевое слово yield . Вот простой пример функции-генератора:
```
def generator_function(): 
    for i in range(10):
        yield i

for item in generator_function():
    print(item)
```

***Генератор, реализующий вычисление чисел Фибоначчи:***</br>
```
def fibon(n):
    a=b=1
    for i in range(n):
        yield a
        a, b = b, a + b


for x in fibon(1000):
    print(x)
```

## Map

**Код без map**<br/>
```
items = [1, 2, 3, 4, 5]
squared = []
for i in items:
    squared.append(i**2)
 ```

**С использованием map**<br/>
```
items = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, items)
```

**Еще один пример использования map**<br/>
```
def multiply(x):
    return (x*x)
def add(x):
    return (x+x)

funcs = [multiply, add]
for i in range(5):
    value = list(map(lambda x: x(i), funcs))
    print(value)
```
`> [0, 0]`<br/>
`> [1, 2]`<br/>
`> [4, 4]`<br/>
`> [9, 6]`<br/>
`> [16, 8]`<br/>

### **Filter**
*filter пример:*<br/>
```
number_list = range(-5, 5)
less_than_zero = list(filter(lambda x: x < 0, number_list)) 
print(less_than_zero)
```
`> [-5, -4, -3, -2, -1]`

***filter уподобляется циклу, но он является встроенной функцией и работает быстрее.***


### **Reduce**
Reduce весьма полезная функция для выполнения вычислений на списке и возвращения единственного результата. Например, если мы хотим посчитать произведение всех элементов списка чисел.
Обычным решением этой задачи будет использования цикла for :
```
product = 1
list = [1, 2, 3, 4]
for num in list:
    product = product * num
print(product)
```   
`> product = 24`

**с reduce:**<br/>
```
from functools import reduce
product = reduce((lambda x, y: x * y), [1, 2, 3, 4])
```
`> 24`


## Структура данных **set**
**set** схож по поведению со списком, за тем исключением, что множества неупорядочены и не могут содержать одинаковые значения. Это бывает очень кстати в определённых случаях. К примеру, вам может потребоваться проверить список на наличие дубликатов. Существует два типичных метода. Первый - использовать цикл for . Как-то так:
```
some_list = ['a', 'b', 'c', 'b', 'd', 'm', 'n', 'n']
duplicates = []
for value in some_list:
    if some_list.count(value) > 1: 
        if value not in duplicates:
            duplicates.append(value)
print(duplicates)
```
`> ['b', 'n']`

Но есть и более простое решение при помощи множества. Вы можете сделать что- нибудь такое:

```
some_list = ['a', 'b', 'c', 'b', 'd', 'm', 'n', 'n']
duplicates = set([x for x in some_list if some_list.count(x) > 1]) 
print(duplicates)
```
`> {'b', 'n'}` - тип set

### **Пересечение множеств**
```
valid = set(['yellow', 'red', 'blue', 'green', 'black']) 
input_set = set(['red', 'brown']) 
print(input_set.intersection(valid))
```
`> {'red'}` - тип set

### **Разность множеств**
```
valid = set(['yellow', 'red', 'blue', 'green', 'black']) 
input_set = set(['red', 'brown']) 
print(input_set.difference(valid))
```
`> {'brown'}` - тип set

Уже никто не создает множества через ```name=set(['value1', 'value2'])```,
хипстеры перешли на ```name={'value1', 'value2'}```. ~~Раньше было лучше.~~


## Тернарные операторы
**Шаблон:**<br/>
`condition_is_true if condition else condition_is_false`

**пример:**<br/>
```
is_fat = True
state = "fat" if is_fat else "not fat"
```
Другим вариантом (менее очевидным и не настолько широко распространенным) является использование кортежей.<br/>
**Шаблон:**<br/>
`(if_test_is_false, if_test_is_true)[test]`

**Пример:**<br/>
```
fat = True
fitness = ("худой", "толстый")[fat]
print("Ты ", fitness)
```
`> Ты толстый`

Это работает поскольку в Python `True == 1` и `False == 0`.</br>
Помимо кортежей можно использовать списки.</br>
Пример выше редко используется и в основном считается плохой практикой у разработчиков, поскольку не является в должной мере "питонистичным" решением. Вдобавок здесь легко ошибиться в последовательности значений в кортеже.</br>
Другой причиной НЕ пользоваться тернарным оператором на кортежах является обработка всего кортежа при исполнении, когда как для if-else оператора такого не происходит.
**Пример:**<br/>
```
condition = True
print(2 if condition else 1/0)
```
`> 2`

Бывает и такое:
```
print((1/0, 2)[condition])
```
***Было вызвано исключение ZeroDivisionError***<br/>
Во втором примере сначала собирается кортеж, а затем находится элемент под заданным индексом. Тернарный оператор на if-else следует обычной логике условного оператора if . Таким образом, если один из случаев может вернуть ошибку или обработка обоих случаев является слишком затратной операцией, то вариант с кортежами точно не стоит использовать.


## Декораторы
> **Декораторы** являются функциями, которые изменяют работу других функций.

***Все в Python является объектом***</br>
Для начала краткая ретроспектива функций в Python:
```
def hi(name="Брандмауэр Файервольский"):
    return "Привет " + name
print(hi())
```
`> 'Привет Брандмауэр Файервольский'`

Мы можем присвоить функцию переменной:<br/>
```
greet = hi
```
Мы ***не используем*** здесь скобки, поскольку наша задача ***не вызвать функцию, а передать её объект*** переменной. Теперь попробуем запустить:<br/>
```
print(greet())
```
`> 'Привет Брандмауэр Файервольский'`

Посмотрим что произойдет, если мы удалим ссылку на оригинальную функцию
```
del hi
print(hi())
```
`> NameError: name 'hi' is not defined`
```
print(greet())
```
`> 'Привет Брандмауэр Файервольский'`

### **Определение функций внутри функций**
```
def hi(name="Питонье"):
    print("Вы внутри функции hi()")
    def greet():
        return "Вы внутри функции greet()"
    def welcome():
        return "Вы внутри функции welcome()"
    print(greet())
    print(welcome())
    print("Вы внутри функции hi()")
hi()
```
`> Вы внутри функции hi()`<br/>
`> Вы внутри функции greet()`<br/>
`> Вы внутри функции welcome()`<br/>
`> Вы внутри функции hi()`<br/>

Пример демонстрирует, что при вызове **hi()** вызываются также функции
**greet()** и **welcome()**. Кроме того, две последние функции недоступны извне **hi()**:<br/>
```
greet()
```
`> NameError: name 'greet' is not defined`

### **Возвращение функции из функции**
```
def hi(name="Питонье"):
    def greet():
        return "Вы внутри функции greet()"
    def welcome():
        return "Вы внутри функции welcome()"
    if name == "Питонье":
        return greet
    else:
        return welcome
a = hi()
print(a)
```
`> <function hi.<locals>.greet at 0x10ef6d790>`

Это наглядно демонстрирует, что переменная `a` теперь указывает на функцию **greet()** в функции **hi()**. Теперь попробуйте:</br>
```
print(a())
```
`> Вы внутри функции greet()`

Через условный оператор мы возвращаем из функции объекты ***greet*** и ***welcome***, а не **greet()** и **welcome()**. Почему? Потому что скобки означают вызов функции, без них мы просто передаем сам объект функции. Достаточно ясно? Давайте я чуть подробнее остановлюсь на этом. Когда мы пишем `a = hi()` , функция **hi()** исполняется и (поскольку имя по умолчанию Питонье) возвращается функция ***greet***. Если мы изменим код на `a = hi(name="Джависто")`, то будет возвращена функция **welcome**. Мы также можем набрать **hi()()** , что вернет `Вы внутри функции greet()***`.<br/>

Передаем функцию в качестве аргумента другой функции:<br/>
```
def hi():
    return "Привет Питонье!"
def doSomethingBeforeHi(func):
    print("Я делаю что-то скучное перед исполнением hi()") 
    print(func())
doSomethingBeforeHi(hi)
```
`> Я делаю что-то скучное перед исполнением hi()`<br/>
`> Привет Питонье!`


Пишем наш первый декоратор
```
def a_new_decorator(a_func): 
    def wrapTheFunction():
        print("Я делаю что-то скучное перед исполнением a_func()") 
        a_func()
        print("Я делаю что-то скучное после исполнения a_func()")
    return wrapTheFunction
def a_function_requiring_decoration():
    print("Я функция, которая требует декорации") 

a_function_requiring_decoration()
```
`> Я функция, которая требует декорации`

```
a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)
```
Теперь функция **a_function_requiring_decoration** обернута в **wrapTheFunction()**
```
a_function_requiring_decoration()
```
`> Я делаю что-то скучное перед исполнением a_func()`<br/>
`> Я функция, которая требует декорации`<br/>
`> Я делаю что-то скучное после исполнения a_func()`<br/>

Обернули функцию, чтобы что—то сделать до и после нее, бывает. А еще можно исользовать спец. символ @:
```
@a_new_decorator
def a_function_requiring_decoration():
    """Эй ты! Задекорируй меня полностью!""" 
    print("Я функция, которая требует декорации")
a_function_requiring_decoration()
```
`> Я делаю что-то скучное перед исполнением a_func()`<br/>
`> Я функция, которая требует декорации`<br/>
`> Я делаю что-то скучное после исполнения a_func()`<br/>

Выражение **@a_new_decorator** это сокращенная версия следующего кода:<br/>
```
a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)
```

Однако, у нашего кода есть одна проблема. Если мы исполним:
```
print(a_function_requiring_decoration.__name__)
```
`> wrapTheFunction`

Мы этого не ожидали! Имя функции должно быть **a_function_requiring_decoration**. В реальности наша функция была заменена на wrapTheFunction. Она перезаписала имя и строку документации оригинальной функции. К счастью, Python предоставляет нам простой инструмент для обхода этой проблемы - ***functools.wraps***. Давайте исправим предыдущий пример, используя ***functools.wraps***:<br/>
```
from functools import wraps
def a_new_decorator(a_func): 
    @wraps(a_func)
    def wrapTheFunction():
        print("Я делаю что-то скучное перед исполнением a_func()")
        a_func()
        print("Я делаю что-то скучное после исполнения a_func()")
    return wrapTheFunction
@a_new_decorator
def a_function_requiring_decoration():
    """Эй ты! Задекорируй меня полностью!""" 
    print("Я функция, которая требует декорации")
print(a_function_requiring_decoration.__name__)
```
`> a_function_requiring_decoration`

Другое дело!

**Макет:**<br/>
```
from functools import wraps 
def decorator_name(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if not can_run:
            return "Функция не будет исполнена"
        return f(*args, **kwargs)
    return decorated
@decorator_name
def func():
    return("Функция исполняется")
can_run = True
print(func())
```
`> Функция исполняется`
```
can_run = False
print(func())
```
`> Функция не будет исполнена`

***Примечание:*** @wraps принимает на вход функцию для декорирования и добавляет функциональность копирования имени, строки документации, списка аргументов и т.д. Это открывает доступ к свойствам декорируемой функции из декоратора.

#### **Варианты использования:**
- **Авторизация**<br/>
Декораторы могут использоваться в веб-приложениях для проверки авторизации пользователя, перед тем как открывать ему доступ к функционалу. Они активно используются в веб-фреймворках Flask и Django. Вот пример проверки авторизации на декораторах:
```
from functools import wraps
def requires_auth(f): 
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        if not auth or not check_auth(auth.username, auth.password):
            authenticate()
        return f(*args, **kwargs)
    return decorated
```
- **Журналирование**<br/>
```
from functools import wraps
    def logit(func):
        @wraps(func)
        def with_logging(*args, **kwargs): 
            print(func.__name__ + " была исполнена") 
            return func(*args, **kwargs)
        return with_logging
 @logit
def addition_func(x): 
    """Считаем что-нибудь""" 
    return x + x
result = addition_func(4)
```
`> addition_func была исполнена`

- **Вложенные декораторы внутри функции** </br>
Давайте вернемся к нашему примеру с журналированием и напишем декоратор, который позволит нам задавать файл для сохранения логов:
```
from functools import wraps
def logit(logfile='out.log'): 
    def logging_decorator(func):
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + " была исполнена"   
            print(log_string)
            # Открываем логфайл и записваем данные
            with open(logfile, 'a') as opened_file:
            # Мы записываем логи в конкретный файл
                opened_file.write(log_string + '\n') 
        return wrapped_function
    return logging_decorator
@logit()
def myfunc1():
    pass
myfunc1()
```
`> myfunc1 была исполнена`

Файл out.log создан и содержит строку выше
```
@logit(logfile='func2.log')
def myfunc2():
    pass
myfunc2()
```
`> myfunc2 была исполнена`<br/>

Файл func2.log создан и содержит строку выше

- **Декораторы из классов** </br>
```
class logit(object):
    def __init__(self, logfile='out.log'):
        self.logfile = logfile

    def __call__(self, func):
        log_string = func.__name__ + " была исполнена"   
        print(log_string)
        # Открываем логфайл и записваем данные
        with open(self.logfile, 'a') as opened_file:
            # Мы записываем логи в конкретный файл
            opened_file.write(log_string + '\n') 
            # Отправляем сообщение
        self.notify()
    def notify(self):
        # Только записываем логи
        pass


@logit()
def myfunc1():
    pass
```
`> myfunc1 была исполнена`

Теперь давайте возьмем подкласс logit и добавим функционал отправки email:

```
class email_logit(logit): 
    """Реализация logit для отправки писем администраторам при вызове   функции"""
    def __init__(self, email='admin@myproject.com', *args, **kwargs):
        self.email = email
        super(email_logit, self).__init__(*args, **kwargs)
    def notify(self):
        # Отправляем письмо в self.email
        # Реализация не будет здесь приведена 
        pass
``` 

@email_logit будет работать также как и @logit , при этом отправляя сообщения на почту администратору помимо журналирования.


## **```__slots__```**
В Python каждый класс может иметь атрибуты экземпляров. По умолчанию, Python использует словарь для хранения атрибутов объекта. Это очень удобно, поскольку позволяет добавлять новые атрибуты во время исполнения программы.</br>
Однако, для небольших классов с известными атрибутами такой подход может стать проблемой. Словари занимают большой объём оперативной памяти. Python не может просто выделить заданное количество памяти при создании объекта для хранения его атрибутов. Поэтому большое число объектов будет занимать много оперативной памяти (речь идёт о тысячах и миллионах). Тем не менее, существует способ обойти эту проблему. Он включает использование **```__slots__```** , чтобы Python не создавал словари под хранение атрибутов, а выделял заданный объём памяти для ограниченного числа атрибутов. Вот пример с использованием **```__slots__```** и без:

**пример без ```__slots__```**<br/>
```
class MyClass(object):
    def __init__(self, name, identifier):
        self.name = name 
        self.identifier = identifier 
        self.set_up()
```

**пример с использованием  ```__slots__``` :**<br/>
```
class MyClass(object):
    __slots__ = ['name', 'identifier'] 
    def __init__(self, name,  identifier):
        self.name = name 
        self.identifier = identifier 
        self.set_up()
```

Второй пример кода уменьшит потребление оперативной памяти. Некоторые отмечают 40-50% сокращение потребления оперативной памяти при использовании этого решения.<br/>
Как вариант, вы может дать шанс PyPy. Он выполняет подобную оптимизацию по умолчанию.<br/>
RAM usage example: https://github.com/ianozsvald/ipython_memory_usage <br/>


## **Collections**
### **defaultdict**
В отличие от **dict** не нужно проверять существует ли ключ в словаре или нет. В результате мы можем писать следующий код:<br/>
```
from collections import defaultdict
colors = (
    ('C#', 'Purple'),
    ('JavaScript', 'Yellow'),
    ('Go', 'Blue'),
    ('Swift', 'Orange'),
    ('Ruby', 'Red'),
    ('C', 'Green'),
)
favourite_colors = defaultdict(list)
for name, color in colors:     
    favourite_colors[name].append(color)
print(favourite_colors)
```
`> defaultdict(<class 'list'>, {'C#': ['Purple'], 'JavaScript': ['Yellow'], 'Go': ['Blue'], 'Swift': ['Orange'], 'Ruby': ['Red'], 'C': ['Green']})`

Другим популярным случаем использования **defaultdict** является добавление элементов в список внутри словаря. Если ключ не существует в словаре, то вы упрётесь в ***KeyError***. **defaultdict** позволяет обойти эту проблему аккуратным образом. Для начала, позвольте привести пример использования **dict** с исключением ***KeyError***, а затем мы посмотрим на пример с **defaultdict**. 
Проблема:
```
some_dict = {} 
some_dict['colors']['favourite'] = "yellow" 
```
`> KeyError: 'colors'`

**Решение:**<br/>
```
import collections
tree = lambda: collections.defaultdict(tree) 
some_dict = tree() 
some_dict['colors']['favourite'] = "yellow" 
```
***Работает без ошибок***
 
Вы можете вывести в консоль **some_dict** используя **json.dumps**. Вот пример:<br/>
```
import json
print(json.dumps(some_dict))
```
`> {"colors": {"favourite": "yellow"}}`


### **OrderedDict**
> **OrderedDict** сохраняет элементы в порядке добавление в словарь. Изменение значения ключа не изменяет его позиции. При этом удаление и повторное добавление перенесет ключ в конец словаря.<br/>

**Проблема:**<br/>
```
colors = {"Red": 198, "Green": 170, "Blue": 160} 
for key, value in colors.items():
    print(key, value)
```
`> Red 198`</br>
`> Green 170`</br>
`> Blue 160`</br>

Элементы выводятся в произвольном порядке(по идее)<br/>

**Решение:**<br/>
```
from collections import OrderedDict
colors = OrderedDict([("Red", 198), ("Green", 170), ("Blue", 160)]) 
for key, value in colors.items():
    print(key, value)
```
`> Red 198`<br/>
`> Green 170`<br/>
`> Blue 160`<br/>

Порядок элементов сохранен(по факту)<br/>


### **counter**
Counter позволяет подсчитывать частоту определенных элементов. К примеру, мы можем использовать его, чтобы посчитать сколько любимых цветов у каждого человека:
```
from collections import Counter
colors = (
    ('C#', 'Purple'),
    ('JavaScript', 'Yellow'),
    ('Go', 'Blue'),
    ('Swift', 'Orange'),
    ('Ruby', 'Red'),
    ('C', 'Green'),
)
favs = Counter(name for name, color in colors)
print(favs)
```
`> Counter({'C#': 1, 'JavaScript': 1, 'Go': 1, 'Swift': 1, 'Ruby': 1, 'C': 1})`

Мы также можем посчитать частоту строк в файле. Пример:
```
with open('filename', 'rb') as f: 
    line_count = Counter(f)
print(line_count)
```

### **deque**
**deque** предлагает нам двустороннюю очередь, которая позволяет добавлять и удалять элементы с обеих сторон. Для начала, вам нужно импортировать модуль **deque** из библиотеки ***collections***:
```
from collections import deque
```
Теперь мы можем создать экземпляр двусторонней очереди:
```
d = deque()
```
Очередь работает подобно списку в Python и имеет схожие методы. Например, вы можете: 
```
from collections import deque
d = deque() 
d.append('1') 
d.append('2') 
d.append('3')
print(len(d))
```
`> 3`</br>
```
print(d[0])
```
`> 1`</br>
```
print(d[-1]) 
```
`> 3`</br>

Мы можем отрезать элементы с обеих сторон очереди:
```
d = deque(range(5))
print(len(d))
```
`> 5`</br>
```
print(d.popleft())
```
`> 0`</br>
```
d.pop()
```
`> 4`</br>
```
print(d)
```
`> deque([0, 1, 2, 3])`</br>

Мы также можем ограничить число элементов, которые может хранить очередь. Таким образом при достижении максимального числа элементов очередь начнет отрезать элементы с другого конца. Это проще объяснить на примере:<br/>
```
d = deque(maxlen=30)
```
Теперь, когда мы попытаемся добавить 31-й элемент - очередь отрежет первый элемент с другого конца. Вы также можете добавлять элементы к очереди с обоих концов:<br/>
```
d = deque([1,2,3,4,5]) 
d.extendleft([0]) 
d.extend([6,7,8]) 
print(d)
```
`> deque([0, 1, 2, 3, 4, 5, 6, 7, 8])`</br>

### **namedtuple**
Вы уже должны быть знакомы с кортежами. Кортеж в Python это неизменяемый список, который позволяет хранить объекты, разделенные запятой. Они практически идентичны спискам, за исключением нескольких важных особенностей. В отличие от списков, вы не можете изменить элемент кортежа. В то же время вы можете обращаться к элементам кортежа по индексам:
```
man = ('Python', 404)
print(man[0])
```
`> Python`</br>

Отлично, так что же тогда **namedtuples**? Этот модуль открывает доступ к удобной структуре данных для простых задач. С помощью именованных кортежей вам не обязательно использовать индексы для обращения к элементам кортежа. Вы можете думать об именованных кортежах как о словарях, но в отличие от словарей они неизменяемы(immutable).
```
from collections import namedtuple
Animal = namedtuple('Animal', 'name age type')
perry = Animal(name="perry", age=31, type="cat")
print(perry)
```
`> Animal(name='perry', age=31, type='cat')`
```
print(perry.name)
```
`> perry`<br/>

Теперь вы можете видеть, что мы можем обращаться к элементам именованного кортежа при помощи их имени и **.** (точки). Давайте чуть подробнее на этом остановимся. Именованный кортеж имеет два обязательных аргумента. Это имя самого кортежа и имена полей кортежа. В примере выше имя нашего кортежа Animal , имена полей соответственно: name , age и type . Именованный кортеж позволяет создавать само-документированные кортежи. Вы сможете легко понять код при первом же взгляде на него. И, поскольку вы не привязаны к индексам, у вас открывается больше возможностей по поддержке своего кода. Помимо этого, именованные кортежи не создают словари для каждого экземпляра, они легковесны и не требуют больше памяти чем обычные кортежи. Это делает их быстрее словарей. Тем не менее, помните, что как и в случае с обычными кортежами, именованный кортеж неизменяем.

## **enum.Enum (Python 3.4+)**
Другой полезной структурой данных является **enum**. Он доступен в модуле enum, начиная с Python 3.4 (также в PyPI как бекпорт под именем ***enum34***). **Enums** (перечисляемый тип) это простой способ организации разных вещей...<br/>
Давайте рассмотрим именованный кортеж Animal из прошлого примера. У него есть поле type . Проблема в том, что его тип - строка. Это создаёт нам несколько проблем. Что если пользователь ввёл Cat , поскольку нажал Shift? Или CAT ? Или kitten ?
Перечисление может помочь обойти эту проблему, позволив не использовать строки. Рассмотрим пример:
```
from collections import namedtuple
from enum import Enum
class Species(Enum):
    cat = 1
    dog = 2
    horse = 3
    aardvark = 4
    butterfly = 5
    owl = 6
    platypus = 7
    dragon = 8
    unicorn = 9
    # Список продолжается...
    # Нам безразличен возраст животного, так что мы используем синонимы
    kitten = 1
    puppy = 2
Animal = namedtuple('Animal', 'name age type')
perry = Animal(name="Perry", age=31, type=Species.cat) 
drogon = Animal(name="Drogon", age=4, type=Species.dragon) 
tom = Animal(name="Tom", age=75, type=Species.cat)
charlie = Animal(name="Charlie", age=2, type=Species.kitten)
```
**А теперь несколько тестов**<br/>
```
print(charlie.type == tom.type)
```
`> True`</br>
```
print(charlie.type)
```
`> Species.cat`</br>

Так у нас куда меньше шансов допустить ошибку. При этом мы должны быть конкретны и использовать только перечисление для определения полей.
Существует три способа получения доступа к перечисляемым элементам. Например, все три метода, представленные ниже, дадут вам значения поля</br>
>cat :</br>
>Species(1)</br> 
>Species['cat']</br>
>Species.cat</br>

### **Enumerate**
> **enumerate** это встроенная в Python функция. Её пользу не передать одной строкой. В то же время большинство новичков и многие опытные разработчики не знакомы с ней. Она позволяет нам итерировать по объекту с параллельным автоматическим счётчиком. </br>
Вот пример:
```
for counter, value in enumerate(some_list): 
    print(counter, value)
```
Это не всё! enumerate принимает также необязательный аргумент, с помощью которого она становится ещё полезнее.
```
my_list = ['apple', 'banana', 'grapes', 'pear'] 
for c, value in enumerate(my_list, 1):
    print(c, value)
```
`> 1 apple`</br>
`> 2 banana`</br>
`> 3 grapes`</br>
`> 4 pear`</br>

Необязательный аргумент позволяет задавать начальное значение счётчика. Вы также можете создать список кортежей, содержащих индекс и элемент, используя список. Пример:</br>
```
my_list = ['apple', 'banana', 'grapes', 'pear']
counter_list = list(enumerate(my_list, 1))
print(counter_list)
```
`> [(1, 'apple'), (2, 'banana'), (3, 'grapes'), (4, 'pear')]`


## **Анализ объекта**
**dir** возвращает список атрибутов и методов объекта.
```
my_list = [1, 2, 3]
print(dir(my_list))
```
`> ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']`

Если мы запустим **dir()** без аргументов, то она вернет нам имена всех объектов в текущей области видимости.

### **type и id**
Функция **type** возвращает тип объекта. </br>
Пример:</br>
```
print(type(''))
```
`> <class 'str'>`</br>

```
print(type([]))
```
`> <class 'list'>`</br>
```
print(type({}))
```
`> <class 'dict'>`</br>
```
print(type(dict))
```
`> <class 'type'>`</br>
```
print(type(3))
```
`> <class 'int'>`</br>

**id возвращает уникальный идентификатор объекта.**</br>
К примеру: </br>
```
name = "Wolan"
print(id(name))
```
`> 139030304`</br>

## **Модуль inspect**
проверка членов объекта, запустив:
```
import inspect
print(inspect.getmembers(str))
```
`> [('__add__', <slot wrapper '__add__' of 'str' objects>), ('__class__', <class 'type'>), ('__contains__', ...`</br>


## **Абстракции списков**
> Абстракция списков (списковое включение или генерация списков) это конструкторы, позволяющие создавать последовательности из других последовательностей. В Python (2 и 3) есть три типа подобных абстракции:</br>
    - абстракции списков</br>
    - абстракции словарей </br>
    - абстракции множеств </br>

### **list абстракции**
Абстракции списков открывают доступ к простому и лаконичному синтаксису генерации списков. Конструкция состоит из квадратных скобок содержащих выражение и оператор for, плюс дополнительные for или if при необходимости. Выражения могут быть любыми, т.е. вам разрешается иметь любые элементы внутри списка. Результатом работы будет новый список после исполнения выражения с оглядкой на for и if.</br>
***Шаблон использования:***</br>
`variable = [out_exp for out_exp in input_list if out_exp == 2]`

**пример:**</br>
```
multiples = [i for i in range(30) if i % 3 == 0]
print(multiples)
```
`> [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]`</br>

### **dict абстракции**
```
mcase = {'a': 10, 'b': 34, 'A': 7, 'Z': 3}
mcase_frequency = { k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys() }
print(mcase_frequency)
```
`> {'a': 17, 'b': 34, 'z': 3}`</br>

В примере выше мы суммируем значения ключей, которые отличаются только регистром. Вы также можете легко поменять местами ключи и значения в словаре:
{v: k for k, v in some_dict.items()}

### **set абстракции**
Абстракции множеств схожи с абстракциями списков. Единственное различие - используются фигурные скобки {}.</br> 
Вот пример:</br>
```
squared = {x**2 for x in [1, 1, 2]}
print(squared)
```
`> {1, 4}`</br>

## **Исключения**
> Код, который может вызвать исключение, помещается в ***try*** блок, обработка исключения - в ***except***. </br>

**Простой пример:**</br>
```
try:
    file = open('test.txt', 'rb')
except IOError as e:
    print('Было вызвано исключение IOError. {}'.format(e.args[-1]))
```
`> Было вызвано исключение IOError. No such file or directory`</br>

### **Обработка множества исключений**
Мы можем использовать три метода обработки множества исключений:</br> ***Первый*** заключается в создании кортежа из всех возможных исключений.</br>
Что-то подобное:</br>
```
try:
    file = open('test.txt', 'rb')
except (IOError, EOFError) as e:
    print("Было вызвано исключение. {}".format(e.args[-1]))
```
`> Было вызвано исключение. No such file or directory`</br>

***Второй*** метод заключается в обработке каждого исключения в отдельном блоке ***except***. Мы можем иметь неограниченное их число (но не менее одного).</br>
Пимер:</br>
```
try:
    file = open('test.txt', 'rb')
except EOFError as e:
    print("Было вызвано исключение EOFError.") 
    raise e
except IOError as e:
    print("Было вызвано исключение IOError.") 
    raise e
```
`> Было вызвано исключение IOError.`</br>
`> Traceback (most recent call last):`</br>
`> raise e`</br>
`> FileNotFoundError: [Errno 2] No such file or directory: 'test.txt'`</br>

Таким образом, если исключение не перехватывается первым блоком ***except*** то оно может быть обработано следующим, или не быть обработанным вовсе.</br>

**Третий** метод заключается в перехвате ВСЕХ исключений:</br>
```
try:
    file = open('test.txt', 'rb')
except Exception:
    # Логирование, если оно вам требуется
    raise 
finally:
    print("Я все равно буду вызван!")
```
`> Я все равно буду вызван!`</br>
Основной код помещается в блок ***try***. Дальше идут блоки ***except***, которые исполняются, если в блоке ***try*** было вызвано определённое исключение. Третьим типом блоков, следующим за двумя первыми, может быть ***finally***. Код в блоке
***finally*** будет исполнен вне зависимости от того, вызвал ли код в блоке ***try*** исключение или нет. Это может быть полезно для финальной "чистки" после работы основного скрипта.</br>
Вот еще один простой пример:</br>
```
try:
    file = open('test.txt', 'rb')
except IOError as e:
    print('Было вызвано исключение IOError. {}'.format(e.args[-1]))
finally:
    print("Я буду напечатан вне зависимости от исключений в блоке try!")
```
`> Было вызвано исключение IOError. No such file or directory`</br>
`> Я буду напечатан вне зависимости от исключений в блоке try!`</br>

### **try/else**
Иногда мы можем захотеть исполнить определенный код, если исключения не было. Это легко сделать с помощью блока ***else***. Вы можете спросить: почему нам нужен ***else***, если мы можем поместить этот код в блок ***try***? Проблема в том, что исключение в этом коде, может быть в свою очередь поймано ***try***, а мы можем этого и не хотеть. В целом, ***else*** нечасто используется.</br>
Пример:</br>
```
try:
    print('Я уверен, исключений не будет!')
except Exception:
    print('Исключение')
else:
    # Любой код, который должен быть исполнен, если исключение в блоке # try не было вызвано, но для которого не должна проводиться обработка исключений
    print('Я буду исполнен, если в try не будет исключений. Мои исключения не будут обрабатываться.') 
finally:
    print('Я буду исполнен в любом случае!')
```
`> Я уверен, исключений не будет!`</br>
`> Я буду исполнен, если в try не будет исключений. Мои исключения не будут обрабатываться.`</br>
`> Я буду исполнен в любом случае!`</br>

Блок ***else***, таким образом, исполняется при отсутствии исключений в блоке ***try***. ***else*** исполняется перед ***finally***.


## **Анонимные функции**
> Анонимные функции это однострочные функции, которые используются в случаях, когда вам не нужно повторно использовать функцию в программе. Они идентичны обыкновенным функциям и повторяют их поведение. 

Шаблон:</br>
`lambda argument: manipulate(argument)`</br>

Пример:</br>
```
add = lambda x, y: x + y
print(add(3, 5))
```
`> 8`</br>

**Примеры, где могут использоваться анонимные функции:**</br>
- **Сортировка списка**</br>
```
a = [(1, 2), (4, 1), (9, 10), (13, -3)] 
a.sort(key=lambda x: x[1])
print(a)
```
`> [(13, -3), (4, 1), (1, 2), (9, 10)]`</br>
- **Параллельная сортировка списков**</br>
```
data = zip(list1, list2)
data.sort()
list1, list2 = map(lambda t: list(t), zip(*data))
```

### **Однострочники**
#### **Простой веб-сервер**
Когда-нибудь хотели быстро передать файл по сети? Тогда вам повезло. В Python есть такая возможность. Перейдите в директорию, которую хотите расшарить по сети, и наберите следующую команду в терминале:</br>
**Python 2 (привет всем, у кого windows xp)**</br>
`python -m SimpleHTTPServer`</br>

**Python 3(ждем 4?)**
`python -m http.server`</br>

**Аккуратный вывод в консоль**</br>
Вы можете выводить списки и словари аккуратно отформатированными в консоль.</br>
Вот готовый код:</br>
```
from pprint import pprint
my_dict = {'name': 'Гвидо', 'age': 'undefined', 'personality': 'awesome'} 
print(my_dict)
```
`{'name': 'Гвидо', 'age': 'undefined', 'personality': 'awesome'}`</br>
Это особенно удобно для словарей. Помимо этого, если вам нужно вывести содержимое JSON файла в терминал в удобочитаемом формате, то:</br>
`cat file.json | python -m json.tool`</br>

#### **Профилирование скрипта**
Это может быть очень полезно для определения узких мест производительности ваших программ:</br>
`python -m cProfile my_script.py`</br>
*Примечание: cProfile это ускоренная реализация profile, написанная на C.*

#### **CSV в JSON**
Выполните следующую команду:</br>
`python -c "import csv,json;print json.dumps(list(csv.reader(open('csv_file.csv'))))"`</br>
*Не забудьте заменить csv_file.csv на желаемое имя файла.*

#### **Сглаживание списка**
Вы можете легко и просто сгладить список, содержащий вложенные списки с помощью ***itertools.chain.from_iterable*** из пакета **itertools**.</br>
Вот простой пример:</br>
```
import itertools
a_list = [[1, 2], [3, 4], [5, 6]] 
print(list(itertools.chain.from_iterable(a_list))) 
```
`> 1, 2, 3, 4, 5, 6]`</br>
**или**</br>
```
print(list(itertools.chain(*a_list)))
```
`> 1, 2, 3, 4, 5, 6]`</br>

### **Однострочные конструкторы**
Позволяют избежать больших кусков повторяющегося кода при инициализации класса: </br>
```
class A(object):
    def __init__(self, a, b, c, d, e, f):
        self.__dict__.update({k: v for k, v in locals().items() if k != 'self'})
```
